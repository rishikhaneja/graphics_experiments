// Generate a torus .obj file.
// Run with: npx tsx scripts/generateTorus.ts > public/models/torus.obj
//
// Parameters: R = major radius, r = minor radius
// Segments: around the tube (tubeSeg) and around the ring (ringSeg)

const R = 1.0;      // distance from center of tube to center of torus
const r = 0.4;      // radius of the tube
const ringSeg = 48;  // segments around the ring
const tubeSeg = 24;  // segments around the tube cross-section

const lines: string[] = ["# Torus â€” generated by generateTorus.ts"];

// Generate vertices, normals, and texture coordinates
for (let i = 0; i <= ringSeg; i++) {
  const theta = (i / ringSeg) * 2 * Math.PI;
  const cosT = Math.cos(theta);
  const sinT = Math.sin(theta);

  for (let j = 0; j <= tubeSeg; j++) {
    const phi = (j / tubeSeg) * 2 * Math.PI;
    const cosP = Math.cos(phi);
    const sinP = Math.sin(phi);

    // Position on the torus surface
    const x = (R + r * cosP) * cosT;
    const y = r * sinP;
    const z = (R + r * cosP) * sinT;

    // Normal = direction from the ring center to the surface point
    const nx = cosP * cosT;
    const ny = sinP;
    const nz = cosP * sinT;

    // UV
    const u = i / ringSeg;
    const v = j / tubeSeg;

    lines.push(`v ${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}`);
    lines.push(`vn ${nx.toFixed(6)} ${ny.toFixed(6)} ${nz.toFixed(6)}`);
    lines.push(`vt ${u.toFixed(6)} ${v.toFixed(6)}`);
  }
}

// Generate faces (quads split into two triangles)
for (let i = 0; i < ringSeg; i++) {
  for (let j = 0; j < tubeSeg; j++) {
    const a = i * (tubeSeg + 1) + j + 1;       // +1 because OBJ is 1-based
    const b = a + 1;
    const c = (i + 1) * (tubeSeg + 1) + j + 1;
    const d = c + 1;

    // Two triangles per quad: a-c-d and a-d-b
    lines.push(`f ${a}/${a}/${a} ${c}/${c}/${c} ${d}/${d}/${d}`);
    lines.push(`f ${a}/${a}/${a} ${d}/${d}/${d} ${b}/${b}/${b}`);
  }
}

process.stdout.write(lines.join("\n") + "\n");
